package codegen

import (
	"bytes"
	"fmt"
	"text/template"
)

const (
	decodeBaseType = iota
	encodeBaseType
	decodeDerivedBaseType
	encodeDerivedBaseType
	decodeBaseSliceType
	encodeBaseSliceType
	decodeCustomSliceType
	encodeCustomSliceType
)
//	coder.Ints((m.C1))
//var c1 int
//coder.Ints(&c1)
//m.C1 = SliceInt(c1)

//coder.Ints(*(*[]int)(unsafe.Pointer(&m.D1)))
//var d1 []int
//coder.Ints(&d1)
//m.D1 = *(*Aints)(unsafe.Pointer(&d1))

var fieldTemplate = map[int]string{
	encodeBaseType: `coder.{{.Method}}({{.ReceiverAlias}}.{{.Field}})`,
	decodeBaseType: `coder.{{.Method}}(&{{.ReceiverAlias}}.{{.Field}})`,
	decodeDerivedBaseType: `var {{.TransientVar}} {{.BaseType}}
	coder.{{.Method}}(&{{.TransientVar}})
	{{.ReceiverAlias}}.{{.Field}} = {{.FieldType}}({{.TransientVar}})`,
	encodeDerivedBaseType: `coder.{{.Method}}({{.BaseType}}({{.ReceiverAlias}}.{{.Field}}))`,
	encodeBaseSliceType:`coder.{{.Method}}(({{.ReceiverAlias}}.{{.Field}}))`,
	decodeBaseSliceType:`var {{.TransientVar}} []{{.BaseType}}
	coder.{{.Method}}(&{{.TransientVar}})
	{{.ReceiverAlias}}.{{.Field}} = {{.TransientVar}}`,
	encodeCustomSliceType: `coder.{{.Method}}(*(*[]{{.BaseType}})(unsafe.Pointer(&{{.ReceiverAlias}}.{{.Field}})))`,
	decodeCustomSliceType: `var {{.TransientVar}} []{{.BaseType}}
	coder.{{.Method}}(&{{.TransientVar}})
	{{.ReceiverAlias}}.{{.Field}} = *(*{{.FieldType}})(unsafe.Pointer(&{{.TransientVar}}))`,

}

const (
	fileCode = iota
	codingStructType
)

var blockTemplate = map[int]string{
	fileCode: `// Code generated by bintly codegen. DO NOT EDIT.\n\n
package {{.Pkg}}

import (
{{.Imports}}
)
{{.Code}}

`,
	codingStructType: `

func ({{.Receiver}}) EncodeBinary(coder *bintly.Writer) error {
{{.EncodingCases}}
	return nil
}



func ({{.Receiver}}) DecodeBinary(coder *bintly.Reader) error {
{{.DecodingCases}}	
	return nil
}

`,
}

func expandTemplate(namespace string, dictionary map[int]string, key int, data interface{}) (string, error) {
	var id = fmt.Sprintf("%v_%v", namespace, key)
	textTemplate, ok := dictionary[key]
	if !ok {
		return "", fmt.Errorf("failed to lookup template for %v.%v", namespace, key)
	}
	temlate, err := template.New(id).Parse(textTemplate)
	if err != nil {
		return "", fmt.Errorf("fiailed to parse template %v %v, due to %v", namespace, key, err)
	}
	writer := new(bytes.Buffer)
	err = temlate.Execute(writer, data)
	return writer.String(), err
}

func expandFieldTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("fieldTemplate", fieldTemplate, key, data)
}

func expandBlockTemplate(key int, data interface{}) (string, error) {
	return expandTemplate("blockTemplate", blockTemplate, key, data)
}
